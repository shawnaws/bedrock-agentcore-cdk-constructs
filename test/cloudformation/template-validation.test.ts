/**
 * CloudFormation Template Validation Tests
 * 
 * This test suite validates the CloudFormation templates generated by our constructs
 * to ensure they follow AWS best practices, security principles, and proper resource
 * naming conventions.
 */

import * as cdk from 'aws-cdk-lib';
import { Template, Match } from 'aws-cdk-lib/assertions';
import { Bucket } from 'aws-cdk-lib/aws-s3';
import { BedrockAgentCoreRuntimeAgent } from '../../src/constructs/bedrock-agentcore/bedrock-agentcore-runtime-agent';
import { BedrockKnowledgeBase } from '../../src/constructs/bedrock/bedrock-knowledge-base';

describe('CloudFormation Template Validation', () => {
    let app: cdk.App;
    let stack: cdk.Stack;
    let testBucket: Bucket;

    beforeEach(() => {
        app = new cdk.App();
        stack = new cdk.Stack(app, 'TestStack', {
            env: {
                account: '123456789012',
                region: 'us-east-1'
            }
        });
        
        testBucket = new Bucket(stack, 'TestBucket');
    });

    describe('CloudFormation Template Snapshots', () => {
        test('should generate consistent template for BedrockAgentCoreRuntimeAgent', () => {
            // Create a minimal knowledge base for the agent
            const knowledgeBase = new BedrockKnowledgeBase(stack, 'MinimalKB', {
                name: 'minimal-kb',
                description: 'Minimal knowledge base for agent testing',
                dataSourceBucket: testBucket,
                dataSourcePrefixes: ['minimal/'],
                knowledgeBaseInstructions: 'Minimal knowledge base for testing'
            });

            const agent = new BedrockAgentCoreRuntimeAgent(stack, 'TestAgent', {
                agentName: 'test-agent',
                instruction: 'You are a helpful assistant',
                projectRoot: './test-project',
                s3Bucket: testBucket,
                s3Prefix: 'agent-data/',
                knowledgeBases: [knowledgeBase]
            });

            const template = Template.fromStack(stack);
            
            // Create snapshot of the template
            expect(template.toJSON()).toMatchSnapshot('bedrock-agent-core-runtime-template');
            expect(agent.agentName).toBe('test-agent');
        });

        test('should generate consistent template for BedrockKnowledgeBase', () => {
            const knowledgeBase = new BedrockKnowledgeBase(stack, 'TestKB', {
                name: 'test-kb',
                description: 'Test knowledge base',
                dataSourceBucket: testBucket,
                dataSourcePrefixes: ['documents/'],
                knowledgeBaseInstructions: 'Use this knowledge base for testing'
            });

            const template = Template.fromStack(stack);
            
            // Create snapshot of the template
            expect(template.toJSON()).toMatchSnapshot('bedrock-knowledge-base-template');
            expect(knowledgeBase.knowledgeBaseName).toBe('test-kb');
        });

        test('should generate consistent template for integrated constructs', () => {
            const knowledgeBase = new BedrockKnowledgeBase(stack, 'TestKB', {
                name: 'test-kb',
                description: 'Test knowledge base',
                dataSourceBucket: testBucket,
                dataSourcePrefixes: ['documents/'],
                knowledgeBaseInstructions: 'Use this knowledge base for testing'
            });

            const agent = new BedrockAgentCoreRuntimeAgent(stack, 'TestAgent', {
                agentName: 'test-agent',
                instruction: 'You are a helpful assistant with knowledge base access',
                projectRoot: './test-project',
                s3Bucket: testBucket,
                s3Prefix: 'agent-data/',
                knowledgeBases: [knowledgeBase]
            });

            const template = Template.fromStack(stack);
            
            // Create snapshot of the integrated template
            expect(template.toJSON()).toMatchSnapshot('integrated-bedrock-constructs-template');
            expect(agent.agentName).toBe('test-agent');
            expect(knowledgeBase.knowledgeBaseName).toBe('test-kb');
        });
    });

    describe('IAM Policy Validation - Least Privilege Principles', () => {
        test('should create IAM policies with minimal required permissions for agent', () => {
            // Create a minimal knowledge base for the agent
            const knowledgeBase = new BedrockKnowledgeBase(stack, 'MinimalKB', {
                name: 'minimal-kb',
                description: 'Minimal knowledge base for agent testing',
                dataSourceBucket: testBucket,
                dataSourcePrefixes: ['minimal/'],
                knowledgeBaseInstructions: 'Minimal knowledge base for testing'
            });

            const agent = new BedrockAgentCoreRuntimeAgent(stack, 'TestAgent', {
                agentName: 'test-agent',
                instruction: 'You are a helpful assistant',
                projectRoot: './test-project',
                s3Bucket: testBucket,
                s3Prefix: 'agent-data/',
                knowledgeBases: [knowledgeBase]
            });

            const template = Template.fromStack(stack);

            // Verify IAM role has correct trust policy
            template.hasResourceProperties('AWS::IAM::Role', {
                AssumeRolePolicyDocument: {
                    Statement: [
                        {
                            Action: 'sts:AssumeRole',
                            Effect: 'Allow',
                            Principal: {
                                Service: 'bedrock-agentcore.amazonaws.com'
                            },
                            Condition: {
                                StringEquals: {
                                    'aws:SourceAccount': '123456789012'
                                },
                                ArnLike: {
                                    'aws:SourceArn': 'arn:aws:bedrock-agentcore:us-east-1:123456789012:*'
                                }
                            }
                        }
                    ]
                }
            });

            // Verify IAM policy has only required permissions
            template.hasResourceProperties('AWS::IAM::Policy', {
                PolicyDocument: {
                    Statement: Match.arrayWith([
                        // Bedrock permissions
                        Match.objectLike({
                            Effect: 'Allow',
                            Action: [
                                'bedrock:InvokeModel',
                                'bedrock:InvokeModelWithResponseStream'
                            ],
                            Resource: '*',
                            Sid: 'BedrockPermissions'
                        }),
                        // S3 permissions scoped to specific bucket and prefix
                        Match.objectLike({
                            Effect: 'Allow',
                            Action: [
                                's3:GetObject',
                                's3:PutObject',
                                's3:DeleteObject',
                                's3:ListBucket'
                            ],
                            Sid: 'S3DataStorage'
                        })
                    ])
                }
            });

            expect(agent.agentName).toBe('test-agent');
        });

        test('should create IAM policies with knowledge base permissions when needed', () => {
            const knowledgeBase = new BedrockKnowledgeBase(stack, 'TestKB', {
                name: 'test-kb',
                description: 'Test knowledge base',
                dataSourceBucket: testBucket,
                dataSourcePrefixes: ['documents/'],
                knowledgeBaseInstructions: 'Use this knowledge base for testing'
            });

            const agent = new BedrockAgentCoreRuntimeAgent(stack, 'TestAgent', {
                agentName: 'test-agent',
                instruction: 'You are a helpful assistant with knowledge base access',
                projectRoot: './test-project',
                s3Bucket: testBucket,
                s3Prefix: 'agent-data/',
                knowledgeBases: [knowledgeBase]
            });

            const template = Template.fromStack(stack);

            // Verify agent has knowledge base permissions
            template.hasResourceProperties('AWS::IAM::Policy', {
                PolicyDocument: {
                    Statement: Match.arrayWith([
                        Match.objectLike({
                            Effect: 'Allow',
                            Action: [
                                'bedrock:Retrieve',
                                'bedrock:RetrieveAndGenerate'
                            ]
                        }),
                        // OpenSearch Serverless permissions for knowledge base access
                        Match.objectLike({
                            Effect: 'Allow',
                            Action: 'aoss:APIAccessAll'
                        })
                    ])
                }
            });

            expect(agent.agentName).toBe('test-agent');
            expect(knowledgeBase.knowledgeBaseName).toBe('test-kb');
        });

        test('should create knowledge base IAM policies with minimal permissions', () => {
            const knowledgeBase = new BedrockKnowledgeBase(stack, 'TestKB', {
                name: 'test-kb',
                description: 'Test knowledge base',
                dataSourceBucket: testBucket,
                dataSourcePrefixes: ['documents/', 'policies/'],
                knowledgeBaseInstructions: 'Use this knowledge base for testing'
            });

            const template = Template.fromStack(stack);

            // Verify knowledge base data source role has correct permissions
            template.hasResourceProperties('AWS::IAM::Policy', {
                PolicyDocument: {
                    Statement: Match.arrayWith([
                        // Bedrock embedding permissions
                        Match.objectLike({
                            Effect: 'Allow',
                            Action: [
                                'bedrock:InvokeModel*',
                                'bedrock:GetFoundationModel'
                            ]
                        }),
                        // S3 permissions scoped to specific prefixes
                        Match.objectLike({
                            Effect: 'Allow',
                            Action: [
                                's3:GetObject*',
                                's3:GetBucket*',
                                's3:List*'
                            ]
                        })
                    ])
                }
            });

            expect(knowledgeBase.knowledgeBaseName).toBe('test-kb');
        });
    });

    describe('Template Synthesis with Different Configurations', () => {
        test('should handle minimal configuration', () => {
            // Create a minimal knowledge base for the agent
            const knowledgeBase = new BedrockKnowledgeBase(stack, 'MinimalKB', {
                name: 'minimal-kb',
                description: 'Minimal knowledge base for agent testing',
                dataSourceBucket: testBucket,
                dataSourcePrefixes: ['minimal/'],
                knowledgeBaseInstructions: 'Minimal knowledge base for testing'
            });

            const agent = new BedrockAgentCoreRuntimeAgent(stack, 'MinimalAgent', {
                agentName: 'minimal-agent',
                instruction: 'Minimal configuration agent',
                projectRoot: './test-project',
                s3Bucket: testBucket,
                s3Prefix: 'minimal/',
                knowledgeBases: [knowledgeBase]
            });

            const template = Template.fromStack(stack);

            // Should create basic resources including the knowledge base
            const roleCount = Object.keys(template.findResources('AWS::IAM::Role')).length;
            const policyCount = Object.keys(template.findResources('AWS::IAM::Policy')).length;
            expect(roleCount).toBeGreaterThanOrEqual(1);
            expect(policyCount).toBeGreaterThanOrEqual(1);
            template.resourceCountIs('Custom::AgentCoreRuntime', 1);
            
            // Should create knowledge base resources
            template.resourceCountIs('AWS::Bedrock::KnowledgeBase', 1);
            template.resourceCountIs('AWS::OpenSearchServerless::Collection', 1);

            expect(agent.agentName).toBe('minimal-agent');
        });

        test('should handle maximum configuration', () => {
            const knowledgeBase1 = new BedrockKnowledgeBase(stack, 'KB1', {
                name: 'kb-1',
                description: 'First knowledge base',
                dataSourceBucket: testBucket,
                dataSourcePrefixes: ['docs/'],
                knowledgeBaseInstructions: 'Use for documentation',
                chunkingStrategy: {
                    maxTokens: 1500,
                    overlapPercentage: 25
                },
                enableIngestionAlarms: true,
                environment: 'prod'
            });

            const knowledgeBase2 = new BedrockKnowledgeBase(stack, 'KB2', {
                name: 'kb-2',
                description: 'Second knowledge base',
                dataSourceBucket: testBucket,
                dataSourcePrefixes: ['policies/'],
                knowledgeBaseInstructions: 'Use for policies',
                chunkingStrategy: {
                    maxTokens: 800,
                    overlapPercentage: 15
                },
                enableIngestionAlarms: true,
                environment: 'prod'
            });

            const agent = new BedrockAgentCoreRuntimeAgent(stack, 'MaximalAgent', {
                agentName: 'maximal-agent',
                instruction: 'Maximal configuration agent with all features',
                projectRoot: './test-project',
                s3Bucket: testBucket,
                s3Prefix: 'maximal/',
                knowledgeBases: [knowledgeBase1, knowledgeBase2],
                protocol: 'HTTPS',
                environment: 'prod',
                enableTracing: true,
                customResourceTimeoutMinutes: 20,
                environmentVars: {
                    'CUSTOM_VAR': 'custom-value',
                    'DEBUG_MODE': 'true'
                }
            });

            const template = Template.fromStack(stack);

            // Should create all resources
            template.resourceCountIs('AWS::Bedrock::KnowledgeBase', 2);
            template.resourceCountIs('AWS::Bedrock::DataSource', 2);
            template.resourceCountIs('AWS::OpenSearchServerless::Collection', 2);
            template.resourceCountIs('AWS::StepFunctions::StateMachine', 2);
            template.resourceCountIs('AWS::Events::Rule', 2);
            template.resourceCountIs('AWS::CloudWatch::Alarm', 6); // 3 per KB
            template.resourceCountIs('Custom::AgentCoreRuntime', 1);

            // Should have production log retention
            template.hasResourceProperties('AWS::Logs::LogGroup', {
                RetentionInDays: 180
            });

            expect(agent.agentName).toBe('maximal-agent');
            expect(knowledgeBase1.knowledgeBaseName).toBe('kb-1');
            expect(knowledgeBase2.knowledgeBaseName).toBe('kb-2');
        });

        test('should handle different environment configurations', () => {
            // Test each environment separately to avoid synthesis conflicts
            const testEnvironment = (env: 'dev' | 'staging' | 'prod') => {
                const envApp = new cdk.App();
                const envStack = new cdk.Stack(envApp, `${env}Stack`, {
                    env: {
                        account: '123456789012',
                        region: 'us-east-1'
                    }
                });
                
                const envBucket = new Bucket(envStack, 'EnvBucket');
                
                const knowledgeBase = new BedrockKnowledgeBase(envStack, 'EnvKB', {
                    name: `${env}-kb`,
                    description: `${env} knowledge base`,
                    dataSourceBucket: envBucket,
                    dataSourcePrefixes: ['documents/'],
                    knowledgeBaseInstructions: `${env} knowledge base instructions`,
                    environment: env
                });

                const agent = new BedrockAgentCoreRuntimeAgent(envStack, 'EnvAgent', {
                    agentName: `${env}-agent`,
                    instruction: `${env} agent instructions`,
                    projectRoot: './test-project',
                    s3Bucket: envBucket,
                    s3Prefix: `${env}-data/`,
                    knowledgeBases: [knowledgeBase],
                    environment: env
                });

                const template = Template.fromStack(envStack);

                // Verify environment-specific configurations
                const expectedRetention = env === 'prod' ? 180 : env === 'staging' ? 30 : 7;
                template.hasResourceProperties('AWS::Logs::LogGroup', {
                    RetentionInDays: expectedRetention
                });

                // Production should have alarms, dev should not
                const expectedAlarmCount = env === 'prod' ? 3 : 0;
                template.resourceCountIs('AWS::CloudWatch::Alarm', expectedAlarmCount);

                expect(agent.agentName).toBe(`${env}-agent`);
                expect(knowledgeBase.knowledgeBaseName).toBe(`${env}-kb`);
            };

            // Test each environment
            testEnvironment('dev');
            testEnvironment('staging');
            testEnvironment('prod');
        });
    });

    describe('Resource Naming Conventions and Tagging', () => {
        test('should follow consistent naming conventions', () => {
            const knowledgeBase = new BedrockKnowledgeBase(stack, 'TestKB', {
                name: 'test-kb',
                description: 'Test knowledge base',
                dataSourceBucket: testBucket,
                dataSourcePrefixes: ['documents/'],
                knowledgeBaseInstructions: 'Use this knowledge base for testing'
            });

            const agent = new BedrockAgentCoreRuntimeAgent(stack, 'TestAgent', {
                agentName: 'test-agent',
                instruction: 'You are a helpful assistant',
                projectRoot: './test-project',
                s3Bucket: testBucket,
                s3Prefix: 'agent-data/',
                knowledgeBases: [knowledgeBase]
            });

            const template = Template.fromStack(stack);

            // Verify IAM role naming follows convention
            template.hasResourceProperties('AWS::IAM::Role', {
                RoleName: Match.absent() // Should use CDK generated names
            });

            // Verify knowledge base naming (CDK generates unique names)
            template.hasResourceProperties('AWS::Bedrock::KnowledgeBase', {
                Name: Match.stringLikeRegexp('^.*test-kb.*$')
            });

            // Verify OpenSearch collection naming follows convention
            template.hasResourceProperties('AWS::OpenSearchServerless::Collection', {
                Name: Match.stringLikeRegexp('^vectorstore.*$')
            });

            // Verify Step Functions state machine naming
            template.hasResourceProperties('AWS::StepFunctions::StateMachine', {
                StateMachineName: Match.stringLikeRegexp('.*ingestion.*')
            });

            expect(agent.agentName).toBe('test-agent');
            expect(knowledgeBase.knowledgeBaseName).toBe('test-kb');
        });

        test('should apply consistent resource tagging', () => {
            const knowledgeBase = new BedrockKnowledgeBase(stack, 'TestKB', {
                name: 'test-kb',
                description: 'Test knowledge base',
                dataSourceBucket: testBucket,
                dataSourcePrefixes: ['documents/'],
                knowledgeBaseInstructions: 'Use this knowledge base for testing',
                environment: 'prod'
            });

            const agent = new BedrockAgentCoreRuntimeAgent(stack, 'TestAgent', {
                agentName: 'test-agent',
                instruction: 'You are a helpful assistant',
                projectRoot: './test-project',
                s3Bucket: testBucket,
                s3Prefix: 'agent-data/',
                knowledgeBases: [knowledgeBase],
                environment: 'prod'
            });

            const template = Template.fromStack(stack);

            // Verify resources have appropriate tags (note: not all resources support tags)
            // Check that the knowledge base has tags if they are supported
            const kbResources = template.findResources('AWS::Bedrock::KnowledgeBase');
            const kbKeys = Object.keys(kbResources);
            if (kbKeys.length > 0) {
                // Knowledge bases may or may not have tags depending on the CDK version
                // Just verify the resource exists with the expected properties
                expect(kbResources[kbKeys[0]].Properties).toHaveProperty('Name');
                expect(kbResources[kbKeys[0]].Properties).toHaveProperty('Description');
            }

            expect(agent.agentName).toBe('test-agent');
            expect(knowledgeBase.knowledgeBaseName).toBe('test-kb');
        });

        test('should handle resource naming conflicts gracefully', () => {
            // Create multiple knowledge bases with similar names
            const kb1 = new BedrockKnowledgeBase(stack, 'KB1', {
                name: 'test-kb',
                description: 'First test knowledge base',
                dataSourceBucket: testBucket,
                dataSourcePrefixes: ['docs1/'],
                knowledgeBaseInstructions: 'First KB instructions'
            });

            const kb2 = new BedrockKnowledgeBase(stack, 'KB2', {
                name: 'test-kb-2',
                description: 'Second test knowledge base',
                dataSourceBucket: testBucket,
                dataSourcePrefixes: ['docs2/'],
                knowledgeBaseInstructions: 'Second KB instructions'
            });

            const agent = new BedrockAgentCoreRuntimeAgent(stack, 'TestAgent', {
                agentName: 'test-agent',
                instruction: 'Agent with multiple similar KBs',
                projectRoot: './test-project',
                s3Bucket: testBucket,
                s3Prefix: 'agent-data/',
                knowledgeBases: [kb1, kb2]
            });

            const template = Template.fromStack(stack);

            // Should create both knowledge bases with unique resource names
            template.resourceCountIs('AWS::Bedrock::KnowledgeBase', 2);
            template.resourceCountIs('AWS::OpenSearchServerless::Collection', 2);

            // Verify unique collection names
            const collections = template.findResources('AWS::OpenSearchServerless::Collection');
            const collectionNames = Object.values(collections).map(
                (collection: any) => collection.Properties.Name
            );
            
            // Names should be different
            expect(collectionNames[0]).not.toBe(collectionNames[1]);
            expect(collectionNames[0]).toMatch(/^vectorstore.*$/);
            expect(collectionNames[1]).toMatch(/^vectorstore.*$/);

            expect(agent.agentName).toBe('test-agent');
            expect(kb1.knowledgeBaseName).toBe('test-kb');
            expect(kb2.knowledgeBaseName).toBe('test-kb-2');
        });
    });

    describe('CloudFormation Template Structure Validation', () => {
        test('should generate valid CloudFormation template structure', () => {
            const knowledgeBase = new BedrockKnowledgeBase(stack, 'TestKB', {
                name: 'test-kb',
                description: 'Test knowledge base',
                dataSourceBucket: testBucket,
                dataSourcePrefixes: ['documents/'],
                knowledgeBaseInstructions: 'Use this knowledge base for testing'
            });

            const agent = new BedrockAgentCoreRuntimeAgent(stack, 'TestAgent', {
                agentName: 'test-agent',
                instruction: 'You are a helpful assistant',
                projectRoot: './test-project',
                s3Bucket: testBucket,
                s3Prefix: 'agent-data/',
                knowledgeBases: [knowledgeBase]
            });

            const template = Template.fromStack(stack);
            const templateJson = template.toJSON();

            // Verify template has required sections (CDK templates don't always have AWSTemplateFormatVersion)
            expect(templateJson).toHaveProperty('Resources');
            expect(templateJson).toHaveProperty('Parameters');
            
            // CDK templates may have additional sections
            if (templateJson.AWSTemplateFormatVersion) {
                expect(templateJson.AWSTemplateFormatVersion).toBe('2010-09-09');
            }

            // Verify no hardcoded values in template
            const templateString = JSON.stringify(templateJson);
            expect(templateString).not.toMatch(/123456789012/); // No hardcoded account IDs
            expect(templateString).not.toMatch(/us-east-1/); // No hardcoded regions (except in ARNs)

            // Verify all resources have proper dependencies
            const resources = templateJson.Resources;
            Object.keys(resources).forEach(resourceKey => {
                const resource = resources[resourceKey];
                
                // IAM policies should depend on roles
                if (resource.Type === 'AWS::IAM::Policy') {
                    expect(resource.Properties.Roles).toBeDefined();
                }

                // Custom resources should have proper service tokens
                if (resource.Type.startsWith('Custom::')) {
                    expect(resource.Properties.ServiceToken).toBeDefined();
                }
            });

            expect(agent.agentName).toBe('test-agent');
            expect(knowledgeBase.knowledgeBaseName).toBe('test-kb');
        });

        test('should validate resource dependencies are correct', () => {
            const knowledgeBase = new BedrockKnowledgeBase(stack, 'TestKB', {
                name: 'test-kb',
                description: 'Test knowledge base',
                dataSourceBucket: testBucket,
                dataSourcePrefixes: ['documents/'],
                knowledgeBaseInstructions: 'Use this knowledge base for testing'
            });

            const agent = new BedrockAgentCoreRuntimeAgent(stack, 'TestAgent', {
                agentName: 'test-agent',
                instruction: 'You are a helpful assistant',
                projectRoot: './test-project',
                s3Bucket: testBucket,
                s3Prefix: 'agent-data/',
                knowledgeBases: [knowledgeBase]
            });

            const template = Template.fromStack(stack);
            const templateJson = template.toJSON();

            // Find data source resource
            const dataSourceKey = Object.keys(templateJson.Resources).find(
                key => templateJson.Resources[key].Type === 'AWS::Bedrock::DataSource'
            );
            
            if (dataSourceKey) {
                const dataSource = templateJson.Resources[dataSourceKey];
                
                // Data source should depend on knowledge base
                expect(dataSource.Properties.KnowledgeBaseId).toBeDefined();
                
                // Should have proper S3 configuration
                expect(dataSource.Properties.DataSourceConfiguration.S3Configuration).toBeDefined();
            }

            // Find Step Functions state machine
            const stateMachineKey = Object.keys(templateJson.Resources).find(
                key => templateJson.Resources[key].Type === 'AWS::StepFunctions::StateMachine'
            );
            
            if (stateMachineKey) {
                const stateMachine = templateJson.Resources[stateMachineKey];
                
                // State machine should have proper IAM role
                expect(stateMachine.Properties.RoleArn).toBeDefined();
                
                // Should have definition (may be inline or referenced)
                expect(stateMachine.Properties).toHaveProperty('DefinitionString');
            }

            expect(agent.agentName).toBe('test-agent');
            expect(knowledgeBase.knowledgeBaseName).toBe('test-kb');
        });

        test('should validate template size and complexity limits', () => {
            // Create a complex stack to test template limits
            const knowledgeBases = [];
            for (let i = 0; i < 3; i++) {
                knowledgeBases.push(new BedrockKnowledgeBase(stack, `KB${i}`, {
                    name: `kb-${i}`,
                    description: `Knowledge base ${i}`,
                    dataSourceBucket: testBucket,
                    dataSourcePrefixes: [`docs${i}/`],
                    knowledgeBaseInstructions: `Instructions for KB ${i}`,
                    enableIngestionAlarms: true
                }));
            }

            const agent = new BedrockAgentCoreRuntimeAgent(stack, 'ComplexAgent', {
                agentName: 'complex-agent',
                instruction: 'Complex agent with multiple knowledge bases',
                projectRoot: './test-project',
                s3Bucket: testBucket,
                s3Prefix: 'complex-agent/',
                knowledgeBases: knowledgeBases,
                environment: 'prod',
                enableTracing: true
            });

            const template = Template.fromStack(stack);
            const templateJson = template.toJSON();
            const templateString = JSON.stringify(templateJson);

            // Verify template is within CloudFormation limits
            expect(templateString.length).toBeLessThan(1000000); // 1MB limit
            
            // Verify resource count is reasonable
            const resourceCount = Object.keys(templateJson.Resources).length;
            expect(resourceCount).toBeLessThan(500); // CloudFormation limit is 500

            // Verify no circular dependencies
            const resources = templateJson.Resources;
            Object.keys(resources).forEach(resourceKey => {
                const resource = resources[resourceKey];
                if (resource.DependsOn) {
                    const dependencies = Array.isArray(resource.DependsOn) 
                        ? resource.DependsOn 
                        : [resource.DependsOn];
                    
                    // Resource should not depend on itself
                    expect(dependencies).not.toContain(resourceKey);
                }
            });

            expect(agent.agentName).toBe('complex-agent');
            expect(knowledgeBases.length).toBe(3);
        });
    });
});